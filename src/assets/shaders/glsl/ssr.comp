#version 450

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba16f) uniform writeonly image2D outSSR;
layout(binding = 1) uniform sampler2D lightingTex;
layout(binding = 2) uniform sampler2D depthTex;
layout(binding = 3) uniform sampler2D normalTex;

layout(push_constant) uniform PushConstants {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
} pc;

const int MAX_STEPS = 64;
const float STEP_SIZE = 0.1;
const float MAX_DISTANCE = 20.0;
const float THICKNESS = 0.5;
const float BINARY_SEARCH_ITERATIONS = 4;

vec3 reconstructWorldPosition(vec2 uv, float depth) {
    vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 viewSpace = pc.invProj * clipSpace;
    viewSpace /= viewSpace.w;
    vec4 worldSpace = pc.invView * viewSpace;
    return worldSpace.xyz;
}
vec3 reconstructViewPosition(vec2 uv, float depth) {
    vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 viewSpace = pc.invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}
vec3 worldToScreenSpace(vec3 worldPos) {
    vec4 viewSpace = pc.view * vec4(worldPos, 1.0);
    vec4 clipSpace = pc.proj * viewSpace;
    clipSpace.xyz /= clipSpace.w;
    vec3 screenSpace;
    screenSpace.xy = clipSpace.xy * 0.5 + 0.5;
    screenSpace.z = clipSpace.z;
    return screenSpace;
}
bool rayMarch(vec3 rayStart, vec3 rayDir, out vec2 hitUV, out float hitDepth) {
    vec3 currentPos = rayStart;
    vec3 stepDir = rayDir * STEP_SIZE;
    for (int i = 0; i < MAX_STEPS; i++) {
        currentPos += stepDir;
        float dist = distance(currentPos, rayStart);
        if (dist > MAX_DISTANCE) {
            return false;
        }
        vec3 screenPos = worldToScreenSpace(currentPos);
        if (screenPos.x < 0.0 || screenPos.x > 1.0 || 
            screenPos.y < 0.0 || screenPos.y > 1.0) {
            return false;
        }
        float sampledDepth = texture(depthTex, screenPos.xy).r;
        vec3 sampledViewPos = reconstructViewPosition(screenPos.xy, sampledDepth);
        vec3 currentViewPos = (pc.view * vec4(currentPos, 1.0)).xyz;
        float depthDiff = currentViewPos.z - sampledViewPos.z;
        if (depthDiff > 0.0 && depthDiff < THICKNESS) {
            vec3 binaryStart = currentPos - stepDir;
            vec3 binaryEnd = currentPos;
            for (int j = 0; j < BINARY_SEARCH_ITERATIONS; j++) {
                vec3 binaryMid = (binaryStart + binaryEnd) * 0.5;
                vec3 binaryScreen = worldToScreenSpace(binaryMid);
                float binarySampledDepth = texture(depthTex, binaryScreen.xy).r;
                vec3 binarySampledViewPos = reconstructViewPosition(binaryScreen.xy, binarySampledDepth);
                vec3 binaryCurrentViewPos = (pc.view * vec4(binaryMid, 1.0)).xyz;
                if (binaryCurrentViewPos.z > binarySampledViewPos.z) {
                    binaryEnd = binaryMid;
                } else {
                    binaryStart = binaryMid;
                }
            }
            vec3 finalScreen = worldToScreenSpace((binaryStart + binaryEnd) * 0.5);
            hitUV = finalScreen.xy;
            hitDepth = finalScreen.z;
            return true;
        }
    }
    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outSSR);
    if (pixel.x >= imageSize.x || pixel.y >= imageSize.y) {
        return;
    }
    
    vec2 uv = (vec2(pixel) + 0.5) / vec2(imageSize);
    float depth = texture(depthTex, uv).r;
    vec3 normal = texture(normalTex, uv).xyz * 2.0 - 1.0;
    if (depth >= 0.9999) {
        imageStore(outSSR, pixel, vec4(0.0));
        return;
    }
    vec3 worldPos = reconstructWorldPosition(uv, depth);
    vec3 cameraPos = vec3(pc.invView[3][0], pc.invView[3][1], pc.invView[3][2]);
    vec3 viewDir = normalize(cameraPos - worldPos);
    vec3 reflectDir = reflect(-viewDir, normalize(normal));
    float facingRatio = dot(normal, viewDir);
    if (facingRatio < 0.1) {
        imageStore(outSSR, pixel, vec4(0.0));
        return;
    }
    
    vec2 hitUV;
    float hitDepth;
    bool hit = rayMarch(worldPos + normal * 0.01, reflectDir, hitUV, hitDepth);
    if (hit) {
        vec4 reflectionColor = texture(lightingTex, hitUV);
        vec2 edgeFade = vec2(1.0) - pow(abs(hitUV * 2.0 - 1.0), vec2(8.0));
        float edgeFactor = min(edgeFade.x, edgeFade.y);
        float fresnelFactor = pow(1.0 - facingRatio, 2.0);
        float finalAlpha = reflectionColor.a * edgeFactor * fresnelFactor;
        imageStore(outSSR, pixel, vec4(reflectionColor.rgb, finalAlpha));
    } else {
        imageStore(outSSR, pixel, vec4(0.0));
    }
}